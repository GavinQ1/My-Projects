;;; ==========================
;;; CMPU-101, Fall 2015 
;;; Assignement 10
;;; Gavin Qi
;;; ==========================



;;; main functions: 0. make-score-chart-veck       (wrapper for making score-chart vector)
;;;                 1. reset-score-chart!     (reset score-chart vector)
;;;                 2. score-chart-normal!         (change values in score-chart according to dices)
;;;                 3. score-chart-special!        (change values in score-chart according to dices) ---> deal with things such as three of a kind/four of a kind
;;;                 4. process-score-chart!   (calculate scores)
;;;                 5. num-matches and sum-vector
;;;                 6. a bunch of predicate functions 


;; score-chart data structure
(define make-score-chart-veck 
  (lambda ()
    (vector
     ;0. ones
     0
     #f
     ;2. twos
     0
     #f
     ;4. threes
     0
     #f
     ;6. fours
     0
     #f
     ;8. fives
     0
     #f
     ;10. sixes
     0
     #f
     ;12. sum
     0
     #f
     ;14. bonus
     0
     #f
     ;16. three-of-a-kind
     0
     #f
     ;18. four-of-a-kind
     0
     #f
     ;20. full-house
     0
     #f
     ;22. small-straight
     0
     #f
     ;24. large-straight
     0
     #f
     ;26. chance
     0
     #f
     ;28. yahtzee
     0
     #f
     ;30. total
     0
     #f
     )))


;; reset score-chart!
(define reset-score-chart!
  (lambda (c)
    (dotimes (i (vector-length c))
             (if (even? i)
                 (vector-set! c i 0)
                 (vector-set! c i #f)))))

;;;  COMPUTE-HISTOGRAM
;;; --------------------------------------------
;;;  INPUT:  VECK-O-DICE, a vector of dice (valued 1 thru 6)
;;;  OUTPUT:  A vector of length 7, where the ith slot contains
;;;    the number of occurrences of i in the VECK-O-DICE.
;;;    Note that the 0th slot of the histogram is ignored.

(define compute-histogram
  (lambda (veck-O-dice)
    (let ((i 0)
          (histy (make-vector 7))
          (len (vector-length veck-O-dice)))
      (while (< i len)
             (vector-set! histy
                          (vector-ref veck-O-dice i)
                          (+ 1 (vector-ref histy (vector-ref veck-O-dice i))))
             (set! i (+ 1 i)))
      histy)))


;;;  IS-THREE-OF-A-KIND?
;;; ---------------------------------------------
;;;  INPUT:  VECK-O-DICE
;;;  OUTPUT:  #t if the vector of dice contains at least 3 of one kind
;;;           #f otherwise.

(define is-three-of-a-kind?
  (lambda (veck-O-dice)
    ; skip the first sloth
    (let ((i 1)
          (histy (compute-histogram veck-O-dice))
          (found-it #f))
      (while (and
              (not found-it)
              (< i (vector-length histy))
              (if (<= 3 (vector-ref histy i))
                  (set! found-it #t))
              (set! i (+ 1 i))))
      found-it)))

;;;  IS-FOUR-OF-A-KIND?
;;; ---------------------------------------------
;;;  INPUT:  VECK-O-DICE
;;;  OUTPUT:  #t if the vector of dice contains at least 4 of one kind
;;;           #f otherwise.

(define is-four-of-a-kind?
  (lambda (veck-O-dice)
    ; skip the first sloth
    (let ((i 1)
          (histy (compute-histogram veck-O-dice))
          (found-it #f))
      (while (and
              (not found-it)
              (< i (vector-length histy))
              (if (<= 4 (vector-ref histy i))
                  (set! found-it #t))
              (set! i (+ 1 i))))
      found-it)))

;;;  IS-YAHTZEE?
;;; ---------------------------------------------
;;;  INPUT:  VECK-O-DICE
;;;  OUTPUT:  #t if the vector of dice contains at least 5 of one kind
;;;           #f otherwise.

(define is-yahtzee?
  (lambda (veck-O-dice)
    ; skip the first sloth
    (let ((i 1)
          (histy (compute-histogram veck-O-dice))
          (found-it #f))
      (while (and
              (not found-it)
              (< i (vector-length histy))
              (if (= 5 (vector-ref histy i))
                  (set! found-it #t))
              (set! i (+ 1 i))))
      found-it)))


;;;  IS-FULL-HOUSE?
;;; ---------------------------------------------
;;;  INPUT:  VECK-O-DICE
;;;  OUTPUT:  #t if the vector of dice contains a combination of 2 of one kind and 3 of one kind
;;;           #f otherwise.

(define is-full-house?
  (lambda (veck-O-dice)
    ; skip the first sloth
    (let ((i 1)
          (histy (compute-histogram veck-O-dice))
          (found-it-1 #f)
          (found-it-2 #f))
      (while (and
              (not (and found-it-1
                        found-it-2))
              (< i (vector-length histy)))
             (if (= 2 (vector-ref histy i))
                 (set! found-it-1 #t))
             (if (= 3 (vector-ref histy i))
                 (set! found-it-2 #t))
             (set! i (+ 1 i)))
      (and found-it-1
           found-it-2))))

;;;  IS-SMALL-STRAIGHT?
;;; ---------------------------------------------
;;;  INPUT:  VECK-O-DICE
;;;  OUTPUT:  #t if the vector of dice contains all of the
;;;   numbers in {1,2,3,4} or {3,4,5,6}, in any order;
;;;   #f otherwise.

(define is-small-straight?
  (lambda (veck-O-dice)
    ; skip the first sloth
    (let ((i 1)
          (histy (compute-histogram veck-O-dice))
          (acc 0))
      (while (and
              (< acc 4)
              (< i (vector-length histy))
              (if (>= (vector-ref histy i) 1)
                  ;; if the current sloth has one or more than one the value
                  ;; add 1 to acc
                  ;; else when there is none of the value in the current sloth set acc to 0
                  ;; the pattern should be #(0 1 2 1 1 0 0) ==> #t
                  ;;                       #(0 1 0 1 1 1 1) ==> #t
                  ;;                       #(0 1 0 0 1 2 1) ==> #f
                  (set! acc (+ 1 acc))
                  (set! acc 0))
              (set! i (+ 1 i))))
      (= acc 4))))

;;;  IS-LARGE-STRAIGHT?
;;; ---------------------------------------------
;;;  INPUT:  VECK-O-DICE
;;;  OUTPUT:  #t if the vector of dice contains all of the
;;;   numbers in {1,2,3,4,5} or {2,3,4,5,6}, in any order;
;;;   #f otherwise.

(define is-large-straight?
  (lambda (veck-O-dice)
    ; skip the first sloth
    (let ((i 1)
          (histy (compute-histogram veck-O-dice))
          (acc 0))
      (while (and
              (< acc 5)
              (< i (vector-length histy))
              (if (= 1 (vector-ref histy i))
                  (set! acc (+ 1 acc))
                  (set! acc 0))
              (set! i (+ 1 i))))
      (= acc 5))))

;;; SUM-VECTOR
;;; ------------------
;;; INPUTS: DICE-VECK, a vector
;;; OUTPUTS: sum of numbers in the vector

(define sum-vector
  (lambda (dice-veck)
    (let ((i 1)
          (histy (compute-histogram dice-veck))
          (acc 0))
      (while (< i (vector-length histy))
             (set! acc (+ acc
                          (* i
                             (vector-ref histy i))))
             (set! i (+ 1 i)))
      acc)))


;;; SCORE-CHART-NORMAL!
;;; -------------------------
;;; INPUTS: DICE-VECK (dices-get-roll)
;;;         C, a score chart vector
;;; OUTPUTS: None
;;; SIDE EFFECT: Record the multiplication of KEEP and its frequency

(define score-chart-normal!
  (lambda (c dice-veck)
    (let* ((i 1)
           (n 0) ;index for score-chart-veck
           (histy (compute-histogram dice-veck))
           (len (vector-length histy)))
      (while (< i len)
             (vector-set! c n (* i (vector-ref histy i)))
             (set! n (+ n 2))
             (set! i (+ i 1))))))


;;;  NUM-MATCHES-HELPER
;;; -----------------------------------------
;;;  INPUTS:  DICE-VECK, a vector of dice
;;;           KEEP, a dice value (one of {1,2,3,4,5,6})
;;;           I, index
;;;  OUTPUT:  The number of entries in DICE-VECK that are the same 
;;;           as the TARGET value

(define num-matches-helper
  (lambda (dice-veck keep i)
    (let ((len (vector-length dice-veck)))
      (cond
        ;; Base case: when dice-veck runs out of index
        ((= i len)
         0)
        ;; Recursive case1: when TARGET is found
        ((= keep
            (vector-ref dice-veck i))
         (+ 1 (num-matches-helper dice-veck keep (+ 1 i))))
        ;; Recursive case2: when TARGET is NOT found
        (else
         (num-matches-helper dice-veck keep (+ 1 i)))))))

;;;  NUM-MATCHES
;;; -----------------------------------------
;;;  INPUTS:  DICE-VECK, a vector of dice
;;;           TARGET, a dice value (one of {1,2,3,4,5,6})
;;;  OUTPUT:  The number of entries in DICE-VECK that are the same 
;;;           as the TARGET value

(define num-matches
  (lambda (dice-veck target)
    (num-matches-helper dice-veck target 0)))


;;; SCORE-CHART-SPECIAL!
;;; --------------------------
;;; INPUTS: DICE-VECK (dices-get-roll)
;;;         C, a score chart vector
;;; OUTPUTS: None
;;; SIDE EFFECT: Record scores for special pattern

(define score-chart-special!
  (lambda (c dice-veck)
    (let ((sum-dice (sum-vector dice-veck)))
      ;; chance catagory: anything and score is the sum of dices
      (vector-set! c 26 sum-dice)
      ;; three of a kind: score is the sum of dices
      (if (is-three-of-a-kind? dice-veck)
          (vector-set! c 16 sum-dice))
      ;; four of a kind: score is the sum of dices
      (if (is-four-of-a-kind? dice-veck)
          (vector-set! c 18 sum-dice))
      ;; full house: score is 25
      (if (is-full-house? dice-veck)
          (vector-set! c 20 25))
      ;; small straight: score is 30
      (if (is-small-straight? dice-veck)
          (vector-set! c 22 30))
      ;; large straight: score is 40
      (if (is-large-straight? dice-veck)
          (vector-set! c 24 40))
      ;; yahtzee: score is 50
      (if (is-yahtzee? dice-veck)
          (vector-set! c 28 50))
      )))


;;; PROCESS-SCORE-CHART!
;;; --------------------------
;;; INPUTS: C, a score chart vector
;;; OUTPUTS: NONE
;;; SIDE EFFECT: calculate scores in the scoer chart

(define process-score-chart!
  (lambda (c) 
    (let ((sum 0)
          (i 0))
      (while (not (> i 10))
             (set! sum (+ sum (vector-ref c i)))
             (set! i (+ i 2)))
      (vector-set! c 12 sum)
      ;; if over or eq 63 there is a bonus
      (if (>= sum 63)
          (vector-set! c 14 35)))
    (let ((total 0)
          (i 12))
      (while (not (> i 28))
             (set! total (+ total (vector-ref c i)))
             (set! i (+ i 2)))
      (vector-set! c 30 total))))


